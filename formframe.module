<?php

/**
 * @file
 * Module hooks and functions for the Form Frame module.
 */

/**
 * Implements hook_hook_info().
 */
function formframe_hook_info() {
  return array(
    'formframe_prebuild_alter' => array('group' => 'formframe'),
    'formframe_prerender_alter' => array('group' => 'formframe'),
    'formframe_parameters' => array('group' => 'formframe'),
    'formframe_parameters_alter' => array('group' => 'formframe'),
  );
}

/**
 * Implements hook_menu().
 */
function formframe_menu() {
  $menu = array();

  $menu['admin/structure/form-frames/settings'] = array(
    'title' => 'Global settings',
    'description' => 'Make global form frame configurations',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('formframe_global_admin'),
    'file' => 'formframe.admin.inc',
    'access arguments' => array('administer form frame'),
  );

  $menu['form/frame/loader.js'] = array(
    'title' => 'Form frame JavaScript loader',
    'type' => MENU_CALLBACK,
    'page callback' => 'formframe_js_loader',
    'page arguments' => array(),
    'file' => 'formframe.loader.inc',
    'access callback' => TRUE,
  );

  foreach (formframe_form_configs() as $path => $config) {
    $menu[$path] = array(
      'title' => $config['title'],
      'type' => MENU_CALLBACK,
      'page callback' => 'formframe_get_form',
      'page arguments' => array($config['form']),
      'access callback' => TRUE,
      'delivery callback' => 'formframe_deliver_html_page',
    );
  }

  return $menu;
}

/**
 * Implements hook_permission().
 */
function formframe_permission() {
  return array(
    'administer form frame' => array(
      'title' => t('Administer form frame'),
      'description' => t('Add new form frames and edit global configurations'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_theme().
 */
function formframe_theme() {
  $registry['formframe'] = array(
    'variables' => array(
      'form' => array(),
      'styles' => '',
      'scripts' => '',
      'head' => '',
      'head_title' => '',
    ),
    'template' => 'formframe',
    'path' => drupal_get_path('module', 'formframe') . '/theme',
  );

  return $registry;
}

/**
 * Implements hook_library().
 */
function formframe_library() {
  return array(
    'framecomm' => array(
      'title' => 'Frame communications',
      'version' => '1.0.0',
      'js' => array(
        drupal_get_path('module', 'formframe') . '/js/framecomm.js' => array(),
      ),
      'dependencies' => array(
        array('system', 'jquery.bbq'),
      ),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function formframe_ctools_plugin_directory($module, $type) {
  // Load the export_ui plugin.
  if ($type === 'export_ui') {
    return 'plugins/export_ui';
  }
}

/**
 * Primary page callback for form frames; basically a wrapper around the core
 * drupal_get_form() function.
 *
 * @see formframe_menu()
 * @see drupal_get_form()
 */
function formframe_get_form($form_id) {
  // Suppress the admin menu.
  if (function_exists('admin_menu_suppress')) {
    admin_menu_suppress();
  }

  $form_state = array();

  $args = func_get_args();
  // Remove $form_id from the arguments.
  array_shift($args);
  $form_state['build_info']['args'] = $args;

  // Attach the form frame configuration in the build info.
  $form_state['build_info']['formframe'] = formframe_form_config(current_path());

  // Allow other modules to alter this config before the form is built.
  drupal_alter('formframe_prebuild', $form_id, $form_state);

  return drupal_build_form($form_id, $form_state);
}

/**
 * HTML page delivery callback. Similar to drupal_deliver_html_page(), but uses
 * our custom html template and renders only the form (no regions).
 *
 * @see drupal_deliver_html_page()
 * @see formframe_menu()
 */
function formframe_deliver_html_page($callback_result = NULL) {
  // If we received a response and we know how to deal with it, deal with it.
  if (isset($callback_result) && !is_int($callback_result)) {
    if (is_null(drupal_get_http_header('Content-Type'))) {
      drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
    }

    // Send appropriate HTTP-Header for browsers and search engines.
    drupal_add_http_header('Content-Language', $GLOBALS['language']->language);

    // Print anything besides a menu constant, assuming it's not NULL or
    // undefined. Allow other modules to do one last alter.
    $config = formframe_form_config(current_path());
    formframe_apply_configs($callback_result, $config);
    drupal_alter('formframe_prerender', $callback_result);
    $page = formframe_render_page($callback_result);
    print theme('formframe', array('form' => $page));

    // Perform end-of-request tasks.
    drupal_page_footer();
  }
  // Otherwise, hand-off to the standard delivery callback.
  else {
    drupal_deliver_html_page($callback_result);
  }
}

/**
 * Form frame page render callback. Similar to drupal_render_page(), but only
 * returns the contents of the main system content region.
 *
 * @see drupal_render_page()
 * @see formframe_deliver_html_page()
 */
function formframe_render_page($page) {
  drupal_set_page_content($page);
  $page = element_info('page');

  // Go through the normal page rendering motions, but separately. This ensures
  // that any global-scope CSS/JS that this form might rely on is included too.
  $page_copy = $page;
  foreach (module_implements('page_build') as $module) {
    $function = $module . '_page_build';
    $function($page_copy);
  }
  drupal_alter('page', $page_copy);
  drupal_render($page_copy);

  // Ultimately, just return the rendered version of the main content area.
  $page['content']['system_main'] = drupal_set_page_content();
  return drupal_render($page['content']['system_main']);
}

/**
 * Implements hook_form_alter().
 */
function formframe_form_alter(&$form, &$form_state, $form_id) {
  // Check that this is a formframe-built form.
  if (isset($form_state['build_info']['formframe'])) {
    $config = $form_state['build_info']['formframe'];
    $path = drupal_get_path('module', 'formframe');

    // Apply redirects as necessary.
    if (!empty($config['redirect'])) {
      $form_state['redirect'] = url($config['redirect'], array(
        'absolute' => TRUE,
        'external' => FALSE,
      ));
    }

    // Add script to automatically target all links to parent.
    $form['#attached']['js'][] = $path . '/js/target-parent.js';

    // Add script to enable communication with the parent.
    $form['#attached']['library'][] = array('formframe', 'framecomm');
    $form['#attached']['js'][] = array(
      'type' => 'file',
      'data' => $path . '/js/framecomm-init.js',
      'group' => JS_LIBRARY,
    );
    $form['#attached']['js'][] = array(
      'type' => 'setting',
      'data' => array(
        'formframe' => array(
          'whitelist' => explode("\n", variable_get('formframe_origin_whitelist', '')),
        ),
      ),
    );

    // Add some inline CSS via query params.
    $form['#attached']['css']['formframe_css_overrides'] = array(
      'data' => formframe_get_css_overrides(),
      'type' => 'inline',
      'weight' => 1000,
      'group' => CSS_THEME,
      'preprocess' => FALSE,
    );
  }
}

/**
 * Template preprocessor for the main formframe chrome.
 */
function template_preprocess_formframe(&$vars) {
  // Take care of all things usually taken care of by core for a page view.
  $vars['styles'] = drupal_get_css();
  $vars['scripts'] = drupal_get_js();
  $vars['head'] = drupal_get_html_head();
  $vars['head_title'] = drupal_get_title();
  $vars['language'] = $GLOBALS['language'];
  $vars['language']->dir = $GLOBALS['language']->direction ? 'rtl' : 'ltr';
  $vars['rdf_namespaces'] = drupal_get_rdf_namespaces();
  $vars['grddl_profile'] = 'http://www.w3.org/1999/xhtml/vocab';
}

/**
 * Applies the provided configurations against a given form.
 * @param array $form
 * @param array $config
 */
function formframe_apply_configs(&$form, $config) {
  $form['#attributes']['target'] = $config['target'];
}

/**
 * Returns an array of form configurations, keyed by expected path.
 *
 * @return array
 *   Returns an array of form configurations.
 *
 * @todo Don't hardcode this. How about ctools?
 */
function formframe_form_configs() {
  return array(
    'form/frame/asset' => array(
      'form' => 'user_register_form',
      'title' => 'Get access now',
      'target' => '_blank',
      'redirect' => '<front>',
    ),
    'form/frame/trial' => array(
      'form' => 'user_register_form',
      'title' => 'Get Tableau Software now',
      'target' => '_parent',
      'redirect' => 'node/16462',
    ),
  );
}

/**
 * Returns an individual form configuration by a given key.
 *
 * @return array
 *   Returns the form configuration. An empty array if none is found.
 */
function formframe_form_config($form) {
  $configs = formframe_form_configs();
  return isset($configs[$form]) ? $configs[$form] : array();
}

/**
 * Returns form frame parameter configurations, optionally filtered by type.
 *
 * @param string $type
 *   (Optional) Filters the results to parameter configurations of a given type.
 *
 * @return array
 *   An associative array of form frame parameter configurations, keyed by
 *   parameter name, and optionally filtered by $type.
 */
function formframe_parameters($type = '*') {
  $return = &drupal_static(__FUNCTION__, array());

  if (!isset($return[$type])) {
    // Load all into static cache if they haven't already.
    if (!isset($return['*'])) {
      // Load and alter form frame parameter configurations.
      $parameters = module_invoke_all('formframe_parameters');
      drupal_alter('formframe_parameters', $parameters);
      $return['*'] = $parameters;
    }

    // Filter parameter configurations by the given type.
    if ($type !== '*') {
      $return[$type] = array();
      foreach ($return['*'] as $parameter => $config) {
        if ($config['type'] === $type) {
          $return[$type][$parameter] = $config;
        }
      }
    }
  }

  return $return[$type];
}

/**
 * Returns safe form frame parameter values from the global page request ($_GET)
 * keyed by the names of the form frame parameter (as opposed to the name of the
 * query parameter).
 *
 * @param string $type
 *   (Optional) Use this to filter down to specific form frame parameter types.
 *
 * @return array
 *   Returns an associative array where the key is the form frame parameter name
 *   (e.g. the keys returned in hook_formframe_parameters()) and the value is
 *   the sanitized value of the query parameter, run through the provided filter
 *   callback (or check_plain by default).
 */
function formframe_parameter_values($type = '*') {
  $values = &drupal_static(__FUNCTION__, array());

  if (!isset($values[$type])) {
    $values[$type] = array();

    // Iterate through defined parameter definitions for this type.
    $parameters = formframe_parameters($type);
    foreach ($parameters as $name => $config) {
      // Normalize the query parameter we're searching for.
      $param = isset($config['query']) ? $config['query'] : $name;

      // Normalize the filter callback we'll be applying.
      $callback = 'check_plain';
      if (isset($config['filter']) && function_exists($config['filter'])) {
        $callback = $config['filter'];
      }

      // If the value is set, run it through the filter and prepare a response.
      if (isset($_GET[$param])) {
        $values[$type][$name] = $callback($_GET[$param]);
      }
    }
  }

  return $values[$type];
}

/**
 * Returns a (safe) string of CSS properties, useful for altering the basic
 * display of a form.
 *
 * @return string
 *   A string of CSS representing the style changes desired.
 */
function formframe_get_css_overrides() {
  $parameters = formframe_parameters('css_override');
  $values = formframe_parameter_values('css_override');
  $styles = array();

  foreach ($values as $param => $value) {
    $css = $parameters[$param];

    // Only account for non-empty CSS styles.
    if (!empty($value)) {
      $value = $css['style'] . ':' . $value . ' !important;';

      if (isset($styles[$css['selector']])) {
        $styles[$css['selector']] .= $value;
      }
      else {
        $styles[$css['selector']] = $value;
      }
    }
  }

  $css_response = '';
  foreach ($styles as $selector => $style) {
    $css_response .= $selector . '{' . $style . "}\n";
  }
  return $css_response;
}

/**
 * Export callback for form frame exportables.
 */
function formframe_export_formframes($context, $indent = '') {
  $output = ctools_export_object('formframes', $context, $indent);
  $translatables = array();
  foreach (array('title') as $key) {
    if (!empty($context->{$key})) {
      $translatables[] = $context->{$key};
    }
  }
  $translatables = array_filter(array_unique($translatables));
  if (!empty($translatables)) {
    $output .= "\n";
    $output .= "{$indent}// Translatables included for use with string extractors like potx.\n";
    sort($translatables);
    foreach ($translatables as $string) {
      $output .= "{$indent}t(" . ctools_var_export($string) . ");\n";
    }
  }
  return $output;
}

/**
 * Save callback for form frame exportables.
 */
function formframe_save_formframes($object) {
  if ($object->export_type & EXPORT_IN_DATABASE) {
    // Existing record.
    $update = array('pid');
  }
  else {
    // New record.
    $update = array();
    $object->export_type = EXPORT_IN_DATABASE;
  }
  $return = drupal_write_record('formframes', $object, $update);

  // Always rebuild the menu when saving a form frames.
  variable_set('menu_rebuild_needed', TRUE);

  return $return;
}

/**
 * Status set callback for form frame exportables.
 */
function formframe_set_status_formframes($object, $status) {
  ctools_export_set_object_status($object, $status);

  // Always rebuild the menu when updating the status of a form frame.
  variable_set('menu_rebuild_needed', TRUE);
}

/**
 * Delete callback for form frame exportables.
 */
function formframe_delete_formframes($object) {
  // If we were sent an object, get the export key from it. Otherwise
  // assume we were sent the export key.
  $value = is_object($object) ? $object->pid : $object;
  db_delete('formframes')
    ->condition('pid', $value)
    ->execute();

  // Always rebuild the menu when deleting a search collection.
  variable_set('menu_rebuild_needed', TRUE);
}
